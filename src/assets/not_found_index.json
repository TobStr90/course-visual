{
  ":1-Beziehung": {
    "pages": [
      "30"
    ],
    "chapters": []
  },
  "Abstraktionshierarchie": {
    "pages": [
      "94"
    ],
    "chapters": []
  },
  "aktives Objekt": {
    "pages": [
      "136",
      "138"
    ],
    "chapters": []
  },
  "aktueller Parameter": {
    "pages": [
      "45"
    ],
    "chapters": []
  },
  "\u00c4nderungsabh\u00e4ngigkeit": {
    "pages": [
      "217"
    ],
    "chapters": []
  },
  "Array-Initialisierer": {
    "pages": [
      "199"
    ],
    "chapters": []
  },
  "Array-Literal": {
    "pages": [
      "126"
    ],
    "chapters": []
  },
  "Attribut und Zustand": {
    "pages": [
      "34"
    ],
    "chapters": []
  },
  "Nachrichtenausdruck": {
    "pages": [
      "37",
      "37"
    ],
    "chapters": []
  },
  "primitiver Ausdruck": {
    "pages": [
      "37"
    ],
    "chapters": []
  },
  "Ausgabestrom": {
    "pages": [
      "201"
    ],
    "chapters": []
  },
  "Auto boxing und unboxing": {
    "pages": [
      "262"
    ],
    "chapters": []
  },
  "Block": {
    "pages": [
      "266"
    ],
    "chapters": []
  },
  "Boxing und Unboxing": {
    "pages": [
      "264"
    ],
    "chapters": []
  },
  "Coding convention": {
    "pages": [
      "329"
    ],
    "chapters": []
  },
  "Compilation unit": {
    "pages": [
      "203"
    ],
    "chapters": []
  },
  "deklariertes Element": {
    "pages": [
      "146"
    ],
    "chapters": []
  },
  "Delegate": {
    "pages": [
      "261"
    ],
    "chapters": []
  },
  "direkte Instanz": {
    "pages": [
      "202"
    ],
    "chapters": []
  },
  "direkte Subklasse": {
    "pages": [
      "108"
    ],
    "chapters": []
  },
  "direkte Superklasse": {
    "pages": [
      "108"
    ],
    "chapters": []
  },
  "Dispatch": {
    "pages": [
      "217"
    ],
    "chapters": []
  },
  "double Dispatch": {
    "pages": [
      "209"
    ],
    "chapters": []
  },
  "dynamische Typpr\u00fcfung": {
    "pages": [
      "178"
    ],
    "chapters": []
  },
  "dynamisches Binden": {
    "pages": [
      "62",
      "271"
    ],
    "chapters": []
  },
  "Exception handling in Eifel": {
    "pages": [
      "277"
    ],
    "chapters": []
  },
  "rekursive Expansion": {
    "pages": [
      "159"
    ],
    "chapters": []
  },
  "dedizierter Export": {
    "pages": [
      "277"
    ],
    "chapters": []
  },
  "Extension": {
    "pages": [
      "146"
    ],
    "chapters": []
  },
  "Fallunterscheidung per dynamischem Binden": {
    "pages": [
      "286"
    ],
    "chapters": []
  },
  "Familien\u00e4hnlichkeit": {
    "pages": [
      "76"
    ],
    "chapters": []
  },
  "formaler Parameter": {
    "pages": [
      "23",
      "45",
      "46",
      "48",
      "125"
    ],
    "chapters": []
  },
  "formaler Parameter eines Blocks": {
    "pages": [
      "61"
    ],
    "chapters": []
  },
  "formaler Typparameter": {
    "pages": [
      "183"
    ],
    "chapters": []
  },
  "Fragile-base-class-Problem": {
    "pages": [
      "302"
    ],
    "chapters": []
  },
  "funktionale Programmiersprache": {
    "pages": [
      "266"
    ],
    "chapters": []
  },
  "funktionale Programmierung": {
    "pages": [
      "3",
      "16",
      "18",
      "60"
    ],
    "chapters": []
  },
  "Garbage collection": {
    "pages": [
      "197"
    ],
    "chapters": []
  },
  "Generalisierung": {
    "pages": [
      "94"
    ],
    "chapters": []
  },
  "generischer Typ": {
    "pages": [
      "183"
    ],
    "chapters": []
  },
  "Getter": {
    "pages": [
      "222",
      "257"
    ],
    "chapters": []
  },
  "Goto": {
    "pages": [
      "63"
    ],
    "chapters": []
  },
  "Home context bei Continuations": {
    "pages": [
      "60"
    ],
    "chapters": []
  },
  "imperative Programmierung": {
    "pages": [
      "16"
    ],
    "chapters": []
  },
  "Implementation": {
    "pages": [
      "57"
    ],
    "chapters": []
  },
  "Implementationsgeheimnis": {
    "pages": [
      "36",
      "57"
    ],
    "chapters": []
  },
  "indirekte Instanz": {
    "pages": [
      "202"
    ],
    "chapters": []
  },
  "lazy Initialisierung": {
    "pages": [
      "131"
    ],
    "chapters": []
  },
  "innere Klasse": {
    "pages": [
      "204"
    ],
    "chapters": []
  },
  "Instanziierung": {
    "pages": [
      "79"
    ],
    "chapters": []
  },
  "Instanziierung eines parametrischen Typs": {
    "pages": [
      "182",
      "184"
    ],
    "chapters": []
  },
  "Instanzmethode": {
    "pages": [
      "84",
      "204"
    ],
    "chapters": []
  },
  "Intension": {
    "pages": [
      "146"
    ],
    "chapters": []
  },
  "Interface": {
    "pages": [
      "57"
    ],
    "chapters": []
  },
  "Interface-als-Typ-Konzept": {
    "pages": [
      "181"
    ],
    "chapters": []
  },
  "interfacebasierte Programmierung": {
    "pages": [
      "178"
    ],
    "chapters": []
  },
  "interner Iterator": {
    "pages": [
      "242",
      "169"
    ],
    "chapters": []
  },
  "Ist-ein-Beziehung": {
    "pages": [
      "94"
    ],
    "chapters": []
  },
  "Iteration": {
    "pages": [
      "63"
    ],
    "chapters": []
  },
  "Kapselung": {
    "pages": [
      "33",
      "52"
    ],
    "chapters": []
  },
  "abstrakte Klasse": {
    "pages": [
      "106"
    ],
    "chapters": []
  },
  "abstrakte Klasse als Interface": {
    "pages": [
      "270"
    ],
    "chapters": []
  },
  "abstrakte Klasse in Eiffel": {
    "pages": [
      "277"
    ],
    "chapters": []
  },
  "abstrakte Klasse vs. Typ": {
    "pages": [
      "178"
    ],
    "chapters": []
  },
  "Klassenmethode in Java": {
    "pages": [
      "204"
    ],
    "chapters": []
  },
  "Klassenvariable in Java": {
    "pages": [
      "204"
    ],
    "chapters": []
  },
  "Klassenschnittstelle": {
    "pages": [
      "313"
    ],
    "chapters": []
  },
  "Klassifikation": {
    "pages": [
      "79"
    ],
    "chapters": []
  },
  "Kommentar": {
    "pages": [
      "57"
    ],
    "chapters": []
  },
  "Komposition": {
    "pages": [
      "32",
      "33"
    ],
    "chapters": []
  },
  "Konstruktor": {
    "pages": [
      "84"
    ],
    "chapters": []
  },
  "Lambda-Ausdruck": {
    "pages": [
      "60",
      "211",
      "241",
      "266"
    ],
    "chapters": []
  },
  "lokale Variable": {
    "pages": [
      "28",
      "45"
    ],
    "chapters": []
  },
  "Metaprogrammiersystem": {
    "pages": [
      "93"
    ],
    "chapters": []
  },
  "Methodenaufruf": {
    "pages": [
      "45",
      "76"
    ],
    "chapters": []
  },
  "Methodenrumpf": {
    "pages": [
      "57"
    ],
    "chapters": []
  },
  "Methodensignatur": {
    "pages": [
      "57"
    ],
    "chapters": []
  },
  "hierarchische Modularisierung": {
    "pages": [
      "312"
    ],
    "chapters": []
  },
  "Multi-dispatch": {
    "pages": [
      "209"
    ],
    "chapters": []
  },
  "Netzwerkmodell": {
    "pages": [
      "27"
    ],
    "chapters": []
  },
  "nominale Typkonformit\u00e4t in Java": {
    "pages": [
      "202"
    ],
    "chapters": []
  },
  "nominale Typkonformit\u00e4tsdeklaration": {
    "pages": [
      "221"
    ],
    "chapters": []
  },
  "Novarianz von Java": {
    "pages": [
      "202"
    ],
    "chapters": []
  },
  "strukturiertes Objekt": {
    "pages": [
      "28"
    ],
    "chapters": []
  },
  "wachsendes Objekt": {
    "pages": [
      "131"
    ],
    "chapters": []
  },
  "Objektgeflecht": {
    "pages": [
      "27"
    ],
    "chapters": []
  },
  "offene Rekursion": {
    "pages": [
      "271"
    ],
    "chapters": []
  },
  "passives Objekt": {
    "pages": [
      "136"
    ],
    "chapters": []
  },
  "parametrischer Polymorphismus": {
    "pages": [
      "177"
    ],
    "chapters": []
  },
  "primitive Methode": {
    "pages": [
      "85"
    ],
    "chapters": []
  },
  "primitiver Typ": {
    "pages": [
      "199"
    ],
    "chapters": []
  },
  "primitiver Typ in Java": {
    "pages": [
      "201"
    ],
    "chapters": []
  },
  "Property": {
    "pages": [
      "257"
    ],
    "chapters": []
  },
  "Protokoll": {
    "pages": [
      "57"
    ],
    "chapters": []
  },
  "Protokollbeschreibung": {
    "pages": [
      "57"
    ],
    "chapters": []
  },
  "Prototyp": {
    "pages": [
      "76"
    ],
    "chapters": []
  },
  "Pseudo-Typvariable Self": {
    "pages": [
      "191",
      "193"
    ],
    "chapters": []
  },
  "Pseudovariable self und super im Home context": {
    "pages": [
      "59"
    ],
    "chapters": []
  },
  "qualifizierter Export": {
    "pages": [
      "270",
      "277"
    ],
    "chapters": []
  },
  "reflektiver Zugriff": {
    "pages": [
      "219"
    ],
    "chapters": []
  },
  "relationales Datenmodell": {
    "pages": [
      "27"
    ],
    "chapters": []
  },
  "Return-Anweisung": {
    "pages": [
      "44",
      "47"
    ],
    "chapters": []
  },
  "Return-Anweisung bei Continuation": {
    "pages": [
      "60"
    ],
    "chapters": []
  },
  "Rollenwechsel eines Objekts": {
    "pages": [
      "178"
    ],
    "chapters": []
  },
  "Runtime type information": {
    "pages": [
      "273"
    ],
    "chapters": []
  },
  "Schl\u00fcsselwort": {
    "pages": [
      "63"
    ],
    "chapters": []
  },
  "Seiteneffekt": {
    "pages": [
      "42",
      "55",
      "332"
    ],
    "chapters": []
  },
  "Setter": {
    "pages": [
      "257"
    ],
    "chapters": []
  },
  "Spezialisierung": {
    "pages": [
      "171"
    ],
    "chapters": []
  },
  "Struktur\u00e4quivalenz": {
    "pages": [
      "159"
    ],
    "chapters": []
  },
  "strukturierte Programmierung": {
    "pages": [
      "63"
    ],
    "chapters": []
  },
  "Subtyppolymorphie": {
    "pages": [
      "177"
    ],
    "chapters": []
  },
  "tats\u00e4chlicher Parameter": {
    "pages": [
      "45"
    ],
    "chapters": []
  },
  "tats\u00e4chlicher Typparameter": {
    "pages": [
      "183"
    ],
    "chapters": []
  },
  "tempor\u00e4re Variable": {
    "pages": [
      "41",
      "45"
    ],
    "chapters": []
  },
  "Weglassen von Typannotation in Strongtalk": {
    "pages": [
      "154"
    ],
    "chapters": []
  },
  "strukturelle Typ\u00e4quivalenz": {
    "pages": [
      "159"
    ],
    "chapters": []
  },
  "Typregel": {
    "pages": [
      "146"
    ],
    "chapters": []
  },
  "optionales Typsystem": {
    "pages": [
      "116",
      "178",
      "235",
      "236",
      "273"
    ],
    "chapters": []
  },
  "Type erasure": {
    "pages": [
      "264"
    ],
    "chapters": []
  },
  "\u00fcberschreiben in Eiffel": {
    "pages": [
      "277"
    ],
    "chapters": []
  },
  "\u00fcberschreiben mit Aufruf von super": {
    "pages": [
      "117"
    ],
    "chapters": []
  },
  "Universalienstreit": {
    "pages": [
      "104"
    ],
    "chapters": []
  },
  "unsicher (unsafe)": {
    "pages": [
      "254"
    ],
    "chapters": []
  },
  "unver\u00e4nderliches Objekt": {
    "pages": [
      "34"
    ],
    "chapters": []
  },
  "ver\u00e4nderliches Objekt": {
    "pages": [
      "34"
    ],
    "chapters": []
  },
  "automatische Einrichtung von Zugriffsmethode": {
    "pages": [
      "93"
    ],
    "chapters": []
  },
  "Zugriffsmodifikator": {
    "pages": [
      "180"
    ],
    "chapters": []
  },
  "Zul\u00e4ssigkeit von Methodenaufrufen": {
    "pages": [
      "158"
    ],
    "chapters": []
  },
  "Zul\u00e4ssigkeit von Zuweisungen": {
    "pages": [
      "149"
    ],
    "chapters": []
  },
  "Zuweisungskompatibilit\u00e4t bei parametrisierten Subtypen": {
    "pages": [
      "186"
    ],
    "chapters": []
  }
}