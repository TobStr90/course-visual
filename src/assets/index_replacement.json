[
{"Generalisierung als": "Generalisierung als Allgemeinbegriff"},
	{"und Zustand": "Attribut und Zustand"},
		{"-wert": "Attributwert"},
			{"Nachrichten-": "Nachrichtenausdruck"},
				{"primitiver": "primitiver Ausdruck"},
					{"Zuweisungs-": "Zuweisungsausdruck"},
						{":1": ":1 Beziehung"},
							{":n": ":n Beziehung"},
								{"leere": "leere Beziehung"},
									{"in C#": "Call by reference in C#"},
										{"Garbage": "Garbage collection"},
											{"heterogene": "heterogene Collection"},
												{"-Klassen": "Collection-Klassen"},
													{"Stream zum Zugriff auf eine": "Stream zum Zugriff auf eine Collection"},
														{"double": "double Dispatch"},
															{"multi": "multi Dispatch"},
																{"single": "single Dispatch"},
																	{"chaining": "Exception chaining"},
																		{"checked": "checked Exception"},
																			{"tunneling": "Exception tunneling"},
																				{"unchecked": "unchecked Exception"},
																					{"in Eifel": "Exception handling in Eifel"},
																						{"rekursive": "rekursive Expansion"},
																							{"rekursiver Typen": "Expansion rekursiver Typen"},
																								{"dedizierter": "dedizierter Export"},
																									{"einer Generalisierung": "Extension einer Generalisierung"},
																										{"gleiche": "gleiche Fallunterscheidung"},
																											{"per dynamischem Binden": "Fallunterscheidung per dynamischem Binden"},
																												{"versteckte": "versteckte Fallunterscheidung"},
																													{"eines Blocks": "formaler Parameter eines Blocks"},
																														{"Ergebnis der": "Ergebnis der Generalisierung"},
																															{"Vorgang der": "Vorgang der Generalisierung"},
																																{"Lazy initialization per": "Lazy initialization per Getter"},
																																	{"bei Continuations": "Home context bei Continuations"},
																																		{"eines Objekts": "Identit\u00e4t eines Objekts"},
																																			{"von Objekten": "Identit\u00e4t von Objekten"},
																																				{"lazy": "lazy Initialisierung"},
  {"f\u00FCr Klassenvariablen": "lazy Initialisierung f\u00FCr Klassenvariablen"},
  {"direkte": "direkte Instanz"},
  {"indirekte": "indirekte Instanz"},
  {"nicht": "nicht instanziierbar"},
  {"einer parametrischen Typdefinition": "Instanziierung einer parametrischen Typdefinition"},
  {"eines parametrischen Typs": "Instanziierung eines parametrischen Typs"},
  {"einer Generalisierung": "Intension einer Generalisierung"},
  {"Marker": "Marker Interface"},
  {"Tagging": "Tagging Interface"},
  {"explizite": "explizite Interfaceimplementierung"},
  {"implizite": "implizite Interfaceimplementierung"},
  {"Zustandswechsel-": "Zustandswechsel-Invariante"},
  {"externe": "externe Iteration"},
  {"interne": "interne Iteration"},
  {"abgeleitete": "abgeleitete Klasse"},
  {"abstrakte": "abstrakte Klasse"},
  {"als Interface": "abstrakte Klasse als Interface"},
  {"in Eiffel": "abstrakte Klasse in Eiffel"},
  {"in Java": "abstrakte Klasse in Java"},
  {"vs. Typ": "abstrakte Klasse vs. Typ"},
  {"Basis-": "Basisklasse"},
  {"konkrete": "konkrete Klasse"},
  {"-definition": "Klassendefinition"},
  {"-hierarchie": "Klassenhierarchie"},
  {"-methode": "Klassenmethode"},
  {"in Java": "Klassenmethode in Java"},
  {"-typ": "Klassentyp"},
  {"-variable": "Klassenvariable"},
  {"in Java": "Klassenvariable in Java"},
  {"von Wildcard-Typen": "Kontravarianz von Wildcard-Typen"},
  {"Beeinflussung durch Return": "Kontrollflussbeeinflussung durch Return"},
  {"primitive": "primitive Kontrollstruktur"},
  {"flache": "flache Kopie"},
  {"tiefe": "tiefe Kopie"},
  {"von Wildcard-Typen": "Kovarianz von Wildcard-Typen"},
  {"Klassen-": "Klassenliteral"},
  {"bin\u00e4re": "bin\u00e4re Methode"},
  {"konstante": "konstante Methode"},
  {"Multi-": "Multi-Methode"},
  {"-aufruf": "Methodenaufruf"},
  {"-definition": "Methodendefinition"},
  {"-kopf": "Methodenkopf"},
  {"-rumpf": "Methodenrumpf"},
  {"-signatur": "Methodensignatur"},
  {"hierarchische": "hierarchische Modularisierung"},
  {"von Programmen": "Modularisierung von Programmen"},
  {"in Java": "nominale Typkonformit\u00e4t in Java"},
  {"von Java": "Novarianz von Java"},
  {"atomares": "atomares Objekt"},
  {"strukturiertes": "strukturiertes Objekt"},
  {"wachsendes": "wachsendes Objekt"},
  {"zusammengesetztes": "zusammengesetztes Objekt"},
  {"klassenbasierte Form": "klassenbasierte Form der Objektorientierung"},
  {"prototypenbasierte Form": "prototypenbasierte Form der Objektorientierung"},
  {"Inklusions-": "Inklusions-Polymorphie"},
  {"vs. Polymorphismus": "Polymorphie vs. Polymorphismus"},
  {"parametrischer": "parametrischer Polymorphismus"},
  {"vs. Polymorphie": "Polymorphismus vs. Polymorphie"},
  {"in Java": "primitiver Typ in Java"},
  {"self und super im Home context": "Pseudovariable self und super im Home context"},
  {"bei Continuation": "Return-Anweisung bei Continuation"},
  {"eines Objekts": "Rollenwechsel eines Objekts"},
  {"eines Moduls": "Schnittstelle eines Moduls"},
  {"von Variablen": "Sichtbarkeitsregeln von Variablen"},
  {"Unterscheidung zwischen": "Unterscheidung zwischen Statik und Dynamik"},
  {"von Objekten": "Struktur von Objekten"},
  {"direkte": "direkte Subklasse"},
  {"in Java": "Subklasse in Java"},
  {"verhaltensbezogenes": "verhaltensbezogenes Subtyping"},
  {"direkte Superklasse": "direkte Superklasse"},
  {"-annotation": "Typannotation"},
  {"als Ausdruck einer Invariante": "Typannotation als Ausdruck einer Invariante"},
  {"fehlerhafte": "fehlerhafte Typannotation"},
  {"in Strongtalk": "Typannotation in Strongtalk"},
  {"Weglassen von": "Weglassen von Typannotation in Strongtalk"},
  {"in Strongtalk": "Weglassen von Typannotation in Strongtalk"},
  {"-\u00e4quivalenz": "Typ\u00e4quivalenz"},
  {"nominale": "nominale Typ\u00e4quivalenz"},
  {"strukturelle": "strukturelle Typ\u00e4quivalenz"},
  {"-erweiterung": "Typerweiterung"},
  {"-expansion": "Typexpansion"},
  {"-fehler": "Typfehler"},
  {"-hierarchie": "Typhierarchie"},
  {"-inferenz": "Typinferenz"},
  {"-invariante": "Typinvariante"},
  {"-konformit\u00e4t": "Typkonformit\u00e4t"},
  {"des Subtypen mit dem Supertypen": "Typkonformit\u00e4t des Subtypen mit dem Supertypen"},
  {"nominale": "nominale Typkonformit\u00e4t"},
  {"strukturelle": "strukturelle Typkonformit\u00e4t"},
  {"-konstruktor": "Typkonstruktor"},
  {"-korrektheit": "Typkorrektheit"},
  {"-pr\u00FCfung": "Typpr\u00FCfung"},
  {"dynamische": "dynamische Typpr\u00FCfung"},
  {"-regel": "Typregel"},
  {"die von Ausdr\u00FCcken einzuhalten sind": "Typregel die von Ausdr\u00FCcken einzuhalten sind"},
  {"zur Zuordnung eines Typs zu Ausdr\u00FCcken": "Typregel zur Zuordnung eines Typs zu Ausdr\u00FCcken"},
  {"-system": "Typsystem"},
  {"optionales": "optionales Typsystem"},
  {"-umwandlung": "Typumwandlung"},
  {"-variable": "Typvariable"},
  {"in Eiffel": "\u00FCberschreiben in Eiffel"},
  {"mit Aufruf von super": "\u00FCberschreiben mit Aufruf von super"},
  {"metasyntaktische": "metasyntaktische Variable"},
  {"bei Typerweiterung": "Vererbung bei Typerweiterung"},
  {"automatische Einrichtung von": "automatische Einrichtung von Zugriffsmethode"},
  {"von Methodenaufrufen": "Zul\u00e4ssigkeit von Methodenaufrufen"},
  {"von Zuweisungen": "Zul\u00e4ssigkeit von Zuweisungen"},
  {"von Zuweisungen und Methodenaufrufen": "Zul\u00e4ssigkeit von Zuweisungen und Methodenaufrufen"},
  {"explizite": "explizite "},
  {"implizite": "implizite "},
  {"linke und rechte Seite": " linke und rechte Seite"},
  {"unzul\u00e4ssige": "unzul\u00e4ssige Zuweisung"},
  {"bei parametrisierten Subtypen": "Zuweisungskompatibilit\u00e4t bei parametrisierten Subtypen"},
  {"unter parametrischem Polymorphismus": "Zuweisungskompatibilit\u00e4t unter parametrischem Polymorphismus"}
]